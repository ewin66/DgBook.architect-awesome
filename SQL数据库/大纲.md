

**四十一、数据库优化**



```
1.在进行表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；
2.多字段表可以进行垂直分表优化，多数据表可以进行水平分表优化；
3.选择恰当的数据类型，如整型的选择；
4.对于强调快速读取的操作，可以考虑使用MyISAM数据库引擎；
5.对较频繁的作为查询条件的字段创建索引；
唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；
更新非常频繁的字段不适合创建索引；
6.编写SQL时使用上面的方式对SQL语句进行优化；
7.使用慢查询工具找出效率低下的SQL语句进行优化；
8.构建缓存，减少数据库磁盘操作；
9.可以考虑结合使用内在型数据库，如Redis，进行混合存储。
```



### 1. 基数

单个列唯一键（distict_keys）的数量叫做基数

当查询结果返回表中 30%  内的数据时，应该走索引（表中数据量小，其实 phone 的等值查询也是）；当查询结果返回的是超过表中 30% 数据时，基本会走全表扫描。

当然了，返回表中 30% 内的数据会走索引，返回超过 30% 数据就使用全表扫描

其实工作中真返回超过 30%  的数据量，本身业务角度就有问题，尤其在 oltp 业务下。

> 如果一个列**基数很低，该列数据分布不均衡**，由于该列数据分布极度不均衡，会导致 SQL  查询**可能走索引，也可能走全表扫描**。
> 做 SQL 优化时，如果怀疑该列数据分布不均衡，我们可以使用 
> **select 列，count(*) from 表 group by 列 order by 2 desc** 来查看列的数据分布。

如果 SQL  语句是单表访问，可能走索引扫描，也可能走全表扫描，也可能走物理物化视图扫描。在不考虑物理物化视图的情况下，单表访问要么走索引扫描，要么走全表扫描。现在，回忆一下，走索引的条件：返回表中 30% 内的数据要么走索引，要么走全表扫描。相信大家看到这里，已经懂得单表访问的优化方法。



### 2. 选择性（SELECTIVITY）

基数与总行数的比值再乘 100% 就是一个列的选择性。

在进行 SQL 优化的时候，单独看列的基数是没有任何意义的，基数相对于总行数才有实际意义





当一个列出现在 where 条件中，该列没有创建索引并且选择性大于 20% 时，那么该列必须创建索引，从而提升 SQL 查询性能。当然了，如果表只有几百条数据，那我们就不用创建索引了。

###  SQL 优化核心的第一个观点：只有大表才会产生性能问题。



### **3. 回表（TABLE ACCESS BY INDEX ROWID）**

当对一个列创建索引之后，索引会包含该**列的键值**及**键值对应行所在的 rowid**。

通过**索引中记录的 rowid 访问表中的数据**就叫**回表**。回表一般是单块读，回表次数太多会严重影响 SQL 性能，如果**回表次数太多**，就不应该走索引扫描，**应该直接走全表扫描。**

在进行 SQL 优化时，一定要注意回表次数！特别是注意回表的物理 IO 次数。

###  **SQL 优化有一核心点：减少回表，也就是网络传输消耗。**

当**要查询的列也包含在索引中**，这个时候就不需要回表，所以我们往往会建立组合索引来消除回表，从而提升性能。

当一个 SQL 有多个过滤条件但是只有一个列或者部分列建立了索引，这个时候回出现回表再过滤，也需要创建组合索引，进而消除回表再过滤，从而提升查询性能。