## [数据层之外

### 有效数据集

废旧数据	失效数据以及当前Query无需的数据

尽量从业务角度，时效时间，领域范围缩小，精准查询减少无关消耗





### 业务计算放到业务层

##### （10）把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果

select * from order where date < = CURDATE()

这不是一个好的SQL实践，应该优化为：

$curDate = date('Y-m-d');

$res = mysql_query(

```
'select * from order where date < = $curDate');
```

原因：

释放了数据库的CPU

多次调用，传入的SQL相同，才可以利用查询缓存



### 禁止为程序使用的账号赋予super权限

 当达到最大连接数限制时，还运行1个有super权限的用户连接
 super权限只能留给DBA处理问题的账号使用

###  对于程序连接数据库账号，遵循权限最小原则

 程序使用数据库账号只能在一个DB下使用，不准跨库
 程序使用的账号原则上不准有drop权限



### 优先优化高并发的 SQL，而不是执行频率低某些“大”SQL

对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL  一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消耗大量 IO 而且响应很慢的  SQL，由于频率低，即使遇到，最多就是让整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。 

### 从全局出发优化，而不是片面调整

尤其是在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。 







## [设计字段

### 尽量使用数字型字段而非字符型

因为处理查询和连接时会逐个比较字符串的每个字符，而对于数字型而言只需要比较一次就够了。 

### 尽可能用varchar/nvarchar代替char/nchar

变长字段存储空间小，对于查询来说，在一个相对较小的字段内搜索效率更高。。。？ 



  ### 禁止在表中建立预留字段

    预留字段的命名很难做到见名识义
    预留字段无法确认存储的数据类型，所以无法选择合适的类型
    对预留字段类型的修改，会对表进行锁定

  ### 禁止大文件

  ##### 在数据库中存储图片，文件等大的二进制数据

    通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时
    通常存储于文件服务器，数据库只存储文件地址信息

##### 免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据

建议把BLOB或是TEXT列分离到单独的扩展表中
Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行
而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型

如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询

TEXT或BLOB类型只能使用前缀索引
 因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的



  ### 优先最小数据类型

  ##### 选择符合存储需要的最小的数据类型

    原因是：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多，
    索引的性能也就越差
    方法：
    将字符串转换成数字类型存储，如：将IP地址转换成整形数据
    mysql提供了两个方法来处理ip地址

##### inet_aton 把ip转为无符号整型(4-8位)

#####  inet_ntoa 把整型的ip转为地址

##### 插入数据前，先用inet_aton把ip地址转为整型，可以节省空间

#####  显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。

##### 对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储

#####  因为：无符号相对于有符号可以多出一倍的存储空间

 SIGNED INT -2147483648~2147483647
 UNSIGNED INT 0~4294967295

##### VARCHAR(N)中的N代表的是字符数，而不是字节数

 使用UTF8存储255个汉字 Varchar(255)=765个字节

### 时间戳

##### 使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间

TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07
TIMESTAMP 占用4字节和INT相同，但比INT可读性高
超出TIMESTAMP取值范围的使用DATETIME类型存储

经常会有人用字符串存储日期型的数据（不正确的做法）
 缺点1：无法用日期函数进行计算和比较
 缺点2：用字符串存储日期要占用更多的空间

### 金额类数据

##### 同财务相关的金额类数据必须使用decimal类型

非精准浮点：float,double
精准浮点：decimal
Decimal类型为精准浮点数，在计算时不会丢失精度
占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节
可用于存储比bigint更大的整型数据

## [Query

### 避免频繁创建和删除临时表，减少系统表资源消耗

### select into和create table

新建临时表时，如果一次性插入数据量很大，使用select into代替create table，避免造成大量log，以提高速度。 

如果数据量不大，为了缓和系统表的资源，先create table，再insert。 

### 拆分大的DELETE和INSERT语句 

因为这两个操作是会锁表的，对于高访问量的站点来说，锁表时间内积累的访问数、数据库连接、打开的文件数等等，可能不仅仅让WEB服务崩溃，还会让整台服务器马上挂了。 

所以，一定要拆分，使用LIMIT条件休眠一段时间，批量处理。 



### --------------

###  2. 拆分复杂的大SQL为多个小SQL

    大SQL:逻辑上比较复杂，需要占用大量CPU进行计算的SQL
    MySQL 一个SQL只能使用一个CPU进行计算
    SQL拆分后可以通过并行执行来提高处理效率
    回到顶部(go to top)
    数据库操作行为规范
    超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作

###  3. 大批量操作可能会造成严重的主从延迟

    主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，
    而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况

###  4. binlog日志为row格式时会产生大量的日志

    大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，
    产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因

###  5. 避免产生大事务操作

    大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响
    特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批


对于大表使用pt-online-schema-change修改表结构

###  避免大表修改产生的主从延迟

###  避免在对表字段进行修改时进行锁表

###  对大表数据结构的修改一定要谨慎

，会造成严重的锁表操作，尤其是生产环境，是不能容忍的

pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器
 把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉

###  把原来一个DDL操作，分解成多个小的批次进行







## [Where

### **注意范围查询语句**

对于联合索引来说，如果存在范围查询，比如between、>、<等条件时，会造成后面的索引字段失效。

### 避免在where中使用!=, >, <操作符

否则引擎放弃使用索引，进行全表扫描。 



### **14、避免在where子句中对字段进行表达式操作**

比如：



```
select user_id,user_project from user_base where age*2=36;
```

中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成：



```
select user_id,user_project from user_base where age=36/2;
```



### 联合索引的最左侧

###### 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）

 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）
 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）
 回到顶部(go to top)
 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）
 重复索引示例：primary key(id)、index(id)、unique index(id)
 冗余索引示例：index(a,b,c)、index(a,b)、index(a)
 回到顶部(go to top)

##### **对于联合索引来说，要遵守最左前缀法则**

举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。 





###  对于频繁的查询优先考虑==使用**覆盖索引**

#####  覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引

覆盖索引的好处:

##### 避免Innodb表进行索引的二次查询

 Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子**节点中所保存的是行的主键信息，**
 如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据
 而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率

可以把随机IO变成顺序IO加快查询效率
 由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每             一行的数据IO要少的多，
 因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO



##### 7）复合索引最左前缀

##### ，并不是值SQL语句的where顺序要和复合索引一致

用户中心建立了(login_name, passwd)的复合索引

select * from user where login_name=? and passwd=?

select * from user where passwd=? and login_name=?

都能够命中索引

select * from user where login_name=?

也能命中索引，满足复合索引最左前缀

select * from user where passwd=?

不能命中索引，不满足复合索引最左前缀



### 状态ENUM

##### （8）使用ENUM而不是字符串

##### 避免使用ENUM类型

修改ENUM值需要使用ALTER语句
ENUM类型的ORDER BY操作效率低，需要额外操作
禁止使用数值作为ENUM的枚举值

>  StatusText  是否string改用**uint/byte** 
>

##### ENUM保存的是TINYINT，

别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。



##### 枚举使用

如果你的系统中真的已经使用了mysql的enum字段类型，[请在查询的时候直接查询值（并加上单引号），这样就不会使用enum自身隐藏的索引值来获取结果了](https://www.cnblogs.com/luoliuniankk/p/9763880.html)。【顺便说一下，enum的默认索引是从NULL开始，如果你允许NULL并default NULL】

　　**建议：**

　　如果字段是字符串，并且长度固定，可以尝试用char，如果是数值型，还是用tinyint<只占一个字节>吧，比较安全稳定，而且即使迁移，问题也不大。





##### ** ENUM值的数量大于2个并少于20个**

如果你的ENUM值只有两个，你完全可以将ENUM换成更加高效的TINYINT(1)或者更更高效的BIT(1)（MySQL5.0.3及以上）。例如: gender ENUM('male', 'female') 可以变换为: is_male BIT(1). 当你只有两个选项时，完全能以布尔值  true/false，结合字段名字中的“is”关键词来区分。至于20个的上限设定，没错，ENUM事实上可以保存多达65535个值，但求你千万别试。超过二十个值会变得很累赘，超过50个必然难于管理与使用。

##### **如果你无论如何都要用ENUM:**

######  **1. ENUM值千万不要使用数值型**

ENUM定义为字符型数据是有原因的。并不是说你使用数值型字段类型去存储数字是错误的，但有充足的证据显示，MySQL内部机制使用数字去引用索引（参考 上面的第七条）。反正不要在ENUM中存储数字，OK？

>  我们插入了 '1' (字符串)，并且不小心插入了 **1 (没有引号，数值型)**。 MySQL 会将我们地数值型数据**当作是枚举索引去处理**（并没有错，但会令人混淆），根据索引可知，ENUM字段的第一个值为 0 。（译：枚举索引由 1 开始） 

###### 　**2. 考虑使用严格模式**

启用严格模式，至少在你插入一个不存在的ENUM值时会报告错误。否则，只会简单地出现一个警告，继而该值被设置为一个空字符串""（枚举索引为0）。抄笔记：如果你设置了IGNORE，错误依然会被忽略。

### 尽量少or

当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决其执行计划优化问题，再加上 MySQL 特有的  SQL 与 Storage 分层架构方式，造成了其性能比较低下，很多时候使用 union all  或者是union(必要的时候)的方式来代替“or”会得到更好的效果。 

##### 避免在where中使用or

[![image](stanrd-sql%E4%BC%98%E5%8C%96.assets/731331-20160817204223828-2247281.png)](http://images2015.cnblogs.com/blog/731331/201608/731331-20160817204223390-801282221.png) 

### Not In/Exists负向条件

##### （1）负向条件查询不能使用索引

select * from order where status!=0 and stauts!=1

not in/not exists都不是好习惯

可以优化为in查询：

select * from order where status in(2,3)

##### **连续的数值尽量用between** 

in和not in关键词慎用，容易导致全表扫面

对连续的数值尽量用between 

##### 2、SQL语句中IN包含的值不应过多**

MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。

##### **区分in和exist**

select * from 表A where id in (select id from 表B)
这句相当于
select * from 表A where exists(select * from 表B where 表B.id=表A.id)
对于表A的每一条数据,都执行select * from 表B where 表B.id=表A.id的存在性判断,如果表B中存在表A当前行相同的id,则exists为真,该行显示,否则不显示 

区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），**如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询**。 

所以**IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况** 





### Like模糊查询

##### （2）前导模糊查询不能使用索引

select * from order where desc like '%XX'

而非前导模糊查询则可以：

select * from order where desc like 'XX%'



那么如何解决这个问题呢，答案：

##### 使用全文索引。

在我们查询中经常会用到select id,fnum,fdst from dynamic_201606 where user_name like '%zhangsan%';  。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。

创建全文索引的SQL语法是：



```
ALTER TABLE `dynamic_201606` ADD FULLTEXT INDEX `idx_user_name` (`user_name`);
```

使用全文索引的SQL语句是：

```
select id,fnum,fdst from dynamic_201606 where match(user_name) against('zhangsan' in boolean mode);
```

注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别。



### NOT NULL可空	非空

##### （6）允许为null的列，查询有潜在大坑

单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集

select * from user where name != 'shenjian'

如果name允许为null，索引不存储null值，结果集中不会包含这些记录。

所以，请使用not null约束以及默认值。

##### **12、避免在where子句中对字段进行null值判断**

对于null的判断会导致引擎放弃使用索引而进行全表扫描。





### 尽量早过滤

在 SQL 编写中同样可以使用这一原则来优化一些 Join 的  SQL。比如我们在多个表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用分好页的结果集与另外的表  Join，这样可以尽可能多的减少不必要的 IO 操作，大大节省 IO 操作所消耗的时间。 

### 避免类型转换

这里所说的“类型转换”是指 where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换： 

人为在column_name 上通过转换函数进行转换直接导致 MySQL(实际上其他数据库也会有同样的问题)无法使用索引，如果非要转换，应该在传入的参数上进行转换，由数据库自己进行转换， 

如果我们传入的数据类型和字段类型不一致，同时我们又没有做任何类型转换处理，MySQL 可能会自己对我们的数据进行类型转换操作，也可能不进行处理而交由存储引擎去处理，这样一来，就会出现索引无法使用的情况而造成执行计划问题。 

### 通配符查询也容易导致全表扫描

### 避免where使用局部变量

sql只有在运行时才解析局部变量。而优化程序必须在编译时访问执行计划，这时并不知道变量值，所以无法作为索引的输入项。 

[![image](stanrd-sql%E4%BC%98%E5%8C%96.assets/731331-20160817204224734-1363734093.png)](http://images2015.cnblogs.com/blog/731331/201608/731331-20160817204224375-1335458864.png) 

### 避免where对字段进行表达式操作

会导致引擎放弃使用索引 

[![image](stanrd-sql%E4%BC%98%E5%8C%96.assets/731331-20160817204225968-697626697.png)](http://images2015.cnblogs.com/blog/731331/201608/731331-20160817204225218-1862842600.png) 

### 避免where对字段进行函数操作

[![image](stanrd-sql%E4%BC%98%E5%8C%96.assets/731331-20160817204226687-1601431007.png)](http://images2015.cnblogs.com/blog/731331/201608/731331-20160817204226343-524591453.png) 

### 不要where ‘=’左边进行函数、算术运算或其他表达式运算

系统可能无法正确使用索引 





## Select

### =（11）强制类型转换会全表扫描

select * from user where phone=13800001234

注意：不要使用select *（潜台词，文章的SQL都不合格 =_=），只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。



 ### =2.避免数据类型的隐式转换

    隐式转换会导致索引失效
    如: select name,phone from customer where id = '111';



### =禁止使用SELECT *  

##### 必须使用SELECT <字段列表> 查询

原因：
消耗更多的CPU和IO以网络带宽资源
无法使用覆盖索引
可减少表结构变更带来的影响

### =** SELECT 指明字段名称**

SELECT*增加很多不必要的消耗（CPU、IO、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。



### Top-Limit明知返回条数

##### 9）**【！】**如果明确知道只有一条结果返回，limit 1能够提高效率

select * from user where login_name=?

可以优化为：

select * from user where login_name=? limit 1

原因：

你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动



## [索引

###  如何选择索引列的顺序

 建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少

 ### 3.充分利用表上已经存在的索引

    避免使用双%号的查询条件。
    如 a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）

### 一个SQL只能利用到复合索引中的一列进行范围查询

 如 有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，
 在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧
 使用left join 或 not exists 来优化not in 操作
 因为not in 也通常会使用索引失效



### （3）数据区分度不大的字段不宜使用索引

select * from user where sex=1

原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。

经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。

### （4）在属性上进行计算不能命中索引

select * from order where YEAR(date) < = '2017'

即使date上建立了索引，也会全表扫描，可优化为值计算：

select * from order where date < = CURDATE()

或者：

select * from order where date < = '2017-01-01'

### （5）大部分是单条查询，使用Hash索引

##### 如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心

select * from user where uid=?

select * from user where login_name=?

原因：

B-Tree索引的时间复杂度是O(log(n))

Hash索引的时间复杂度是O(1)

1. ### 限制每张表上的索引数量，建议单张表索引不超过5个

   索引并不是越多越好！索引可以提高效率同样可以降低效率

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率

因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个
 索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能

1. ### 禁止给表中的每一列都建立单独的索引

   5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好

2. ### 每个Innodb表必须有个主键

   Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的
   每个表都可以有多个索引，但是表的存储顺序只能有一种
   Innodb是按照主键索引的顺序来组织表的

### 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）

 不要使用UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）

###  主键建议使用自增ID值

 回到顶部(go to top)
 常见索引列建议
 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列

包含在ORDER BY、GROUP BY、DISTINCT中的字段

并不要将符合1和2中的字段的列都建立一个索引， 通常将1、2中的字段建立联合索引效果更好

###  尽量避免使用外键约束

 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引
 外键可用于保证数据的参照完整性，但建议在业务端实现
 外键会影响父表和子表的写操作从而降低性能



## [Join联表关联操作



### 多表join的关联列



**关于[JOIN优化](http://blog.itpub.net/31555484/viewspace-2565387/)**

##### Join种类

![img](stanrd-sql%E4%BC%98%E5%8C%96.assets/23cf3294a2af827b-1571829626906.jpeg)



LEFT JOIN A表为驱动表，INNER JOIN MySQL会自动找出那个数据少的表作用驱动表，RIGHT JOIN B表为驱动表。

**注意：**

##### 1）MySQL中没有full join，可以用以下方式来解决：



```
select * from A left join B on B.name = A.namewhere B.name is nullunion allselect * from B;
```

##### 2）尽量使用inner join，避免left join：

参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。

##### 3）合理利用索引：

被驱动表的索引字段作为on的限制字段。

##### 4）利用小表去驱动大表：

![img](stanrd-sql%E4%BC%98%E5%8C%96.assets/370eac2902dda80e-1571829626932.jpeg)



从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。

##### 5）巧用STRAIGHT_JOIN：

inner join是由MySQL选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using  filesort」、「Using  temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。

![img](stanrd-sql%E4%BC%98%E5%8C%96.assets/f753ea0f23dd6091-1571829626977.jpeg)



这个方式有时能减少3倍的时间。



---

###  1. 避免使用JOIN关联太多的表

    对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置
    在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，
    所占用的内存也就越大

如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，
 就会影响到服务器数据库性能的稳定性

同时对于关联操作来说，会产生临时表操作，影响查询效率
 Mysql最多允许关联61个表，建议不超过5个

### - 复杂多表尽量少用join

MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL  优化器效率高，但是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。对于复杂的多表 Join，一方面由于其优化器受限，再者在  Join 这方面所下的功夫还不够，所以性能表现离 Oracle  等关系型数据库前辈还是有一定距离。但如果是简单的单表查询，这一差距就会极小甚至在有些场景下要优于这些数据库前辈。 

### - 尽量用join代替子查询

虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。 

MySQL需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句在临时表中查询记录。查询完毕后，MySQL需要插销这些临时表。所以在MySQL中可以使用连接查询来代替子查询。连接查询不需要建立临时表，其速度比子查询要快。 

> ##### 子查询性能差的原因：
>
> 子查询的结果集无法使用索引，通常子查询的**结果集会被存储到临时表中**，不论是内存临时表还是磁盘临时表都**不会存在索引**，所以查询性能会受到一定的影响
>  特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；
>  由于子查询会产生**大量的临时表也没有索引**，所以会消耗过多的CPU和IO资源，产生大量的慢查询



###  1. 减少同数据库的交互次数

    数据库更适合处理批量操作
    合并多个相同的操作到一起，可以提高处理效率

###  2. 对应同一列进行or判断时，使用in代替or

    in 的值不要超过500个
    in 操作可以更有效的利用索引，or大多数情况下很少能利用到索引

###  3. 禁止使用order by rand() 进行随机排序

    会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，
    就会消耗大量的CPU和IO及内存资源
    推荐在程序中获取一个随机值，然后从数据库中获取数据的方式

###  4. WHERE从句中禁止对列进行函数转换和计算

    对列进行函数转换或计算时会导致无法使用索引

不推荐：
 where date(create_time)='20190101'
 推荐：
 where create_time >= '20190101' and create_time < '20190102'

###  1. 在明显不会有重复值时使用UNION ALL 而不是UNION

    UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
    UNION ALL 不会再对结果集进行去重操作

**尽量用 union all 代替 union**

union 和 union all 的差异主要是前者需要将两个(或者多个)结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的  CPU 运算，加大资源消耗及延迟。所以**当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候**，尽量使用 union all 而不是  union。 













## [**MS	SQL	Server**

###  [NOLOCK和ROWLOCK](https://www.cnblogs.com/moon25/archive/2008/07/20/1247157.html)

 SQL Server开始是用行级锁的，但是经常会扩大为页面锁和表锁，最终造成死锁 
 　即使用户没有修改数据，SQL Server在SELECT的时候也会遇到锁。幸运的是，我们可以通过SQL Server 的两个关键字来手工处理：NOLOCK和ROWLOCK。 
 　它们的使用方法如下： 
 　SELECT COUNT(UserID) 
 　FROM Users WITH (NOLOCK) 
 　WHERE Username LIKE 'foobar' 
 　和 
 　UPDATE Users WITH (ROWLOCK) 
 　SET Username = 'fred' WHERE Username = 'foobar'  



### 使用`ROW_NUMBER`分页：

```
WITH cte AS(
    select a.*,ag.Name as AgentServerName,d.Name as MgrObjTypeName,l.UserName as userName,b.AddrId
            ,ROW_NUMBER() OVER(ORDER BY AlarmTime DESC) AS RowNo
        from eventlog as a WITH(FORCESEEK) 
            left join mgrobj as b on a.MgrObjId=b.Id and a.AgentBm=b.AgentBm 
            left join addrnode as c on b.AddrId=c.Id 
            left join mgrobjtype as d on b.MgrObjTypeId=d.Id 
            left join eventdir as e on a.EventBm=e.Bm 
            left join agentserver As ag on a.AgentBm=ag.AgentBm 
            left join loginUser as l on a.cfmoper=l.loginGuid 
        where a.AlarmTime>='2014-12-01 00:00:00' and a.AlarmTime<='2014-12-26 23:59:59' 
            AND b.AddrId in ('02109000',……,'02109002')
)
SELECT * FROM cte WHERE RowNo BETWEEN 1 AND 20;
```

执行时间从14秒提升到5秒，这说明Row_Number分页还是比较高效的，而且这种写法比`top top`分页优雅很多。

 







## [------



参考资料 

http://blog.csdn.net/eric_sunah/article/details/17510939 

http://ju.outofmemory.cn/entry/89569 

流年素心  http://www.cnblogs.com/lddbupt/
