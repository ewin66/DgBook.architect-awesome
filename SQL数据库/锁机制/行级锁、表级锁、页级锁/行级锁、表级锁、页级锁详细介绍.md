#  		 [Mysql表锁、行锁、页锁](https://www.cnblogs.com/charlesblc/p/6288228.html) 		

参考 http://www.jb51.net/article/50047.htm 《MySQL行级锁、表级锁、页级锁详细介绍》

##  三种	 **范围** 等级锁

页级:引擎 BDB。
表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行
行级:引擎 INNODB ， 单独的一行记录加锁 （更详细的行锁、表锁，可以参考：http://www.cnblogs.com/charlesblc/p/5935326.html）

 

表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许
行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

上述三种锁的特性可大致归纳如下：
1） 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2） 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3） 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。



### 全局锁：

https://blog.csdn.net/qq_42322103/article/details/90480756

[全局锁能够对整个数据库实例加锁，使得整个库处于只读状态](https://blog.csdn.net/qq_42322103/article/details/90480756)，同时会阻塞DML和DDL语句以及更新类事务的提交语句。

flush tables with read lock;（简称FTWRL）命令可为数据库加全局锁
释放全局锁的语句也很简单：unlock tables;
此外，在客户端异常断开后，全局锁会自动释放。

全局锁非常典型使用场景是做全库逻辑备份。也就是把整库每个表都select出来存成文本。

通过FTWRL可以确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。

    如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
    如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

但是它的优势也很明显，能够解决因为数据更新问题导致的不一致性。
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756



 ## 表级锁

加表锁的方式：

```mysql
mysql> LOCK TABLES real_table WRITE, insert_table WRITE;
mysql> INSERT INTO real_table SELECT * FROM insert_table;
mysql> TRUNCATE TABLE insert_table;
mysql> UNLOCK TABLES;
```



 



MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。

### 表共享读锁（Table Read Lock）

### 表独占写锁（Table Write Lock）

当一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，此时MySQL将会如优先处理进程呢？通过研究表明，写进程将先获得锁（即使读请求先到锁等待队列）。但这也造成一个很大的缺陷，即大量的写操作会造成查询操作很难获得读锁，从而可能造成永远阻塞。其机制是通过控制一个系统变量（concurrent_insert）来改变，更详细的见原文。

 

MyISAM表的读和写是串行的，即在进行读操作时不能进行写操作，反之也是一样。但在一定条件下MyISAM表也支持查询和插入的操作的并发进行，其机制是通过控制一个系统变量（concurrent_insert）来进行的。（更详细的见原文）











## 事务 ACID属性

InnoDB锁与MyISAM锁的最大不同在于：一是支持事务（TRANCSACTION），二是采用了行级锁。我们知道事务是由一组SQL语句组成的逻辑处理单元，其有四个属性（简称ACID属性），分别为：

### 原子性（Atomicity）：

事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行；

### 一致性（Consistent）：

在事务开始和完成时，数据都必须保持一致状态；

### 隔离性（Isolation）：

数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行；

### 持久性（Durable）：

事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

##  行锁InnoDB

#####   **InnoDB有两种模式的行锁：**

### 共享锁【S锁】

1）共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
  ( Select * from table_name where ......lock in share mode)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

### 排他锁【X锁】

2）排他锁：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和 排他写锁。

(select * from table_name where.....for update)

又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。
注意这个时候,既不能加S锁也不能加X锁
————————————————





故名思议，行锁即对行数据行进行加锁，这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。。行锁在引擎层由n各个数据库引进行擎独自实现。因此，如MyISAM没有行锁，InnoDB则有行锁。

不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB拥有支持行锁的特性，这也是MyISAM被InnoDB替代的重要原因之一。

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

    两阶段锁协议指的是事务的执行分为两个阶段
    
        扩展阶段（此阶段只能创建锁而不能释放锁，即需要加锁的时候才加锁）
        收缩阶段(只能释放锁而不加锁）
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756





## 页锁

页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。
在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。
使用页级锁定的主要是BerkeleyDB存储引擎。
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756