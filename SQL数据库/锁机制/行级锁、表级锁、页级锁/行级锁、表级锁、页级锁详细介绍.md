#  		 [Mysql表锁、行锁、页锁](https://www.cnblogs.com/charlesblc/p/6288228.html) 		

参考 http://www.jb51.net/article/50047.htm 《MySQL行级锁、表级锁、页级锁详细介绍》

##  三种	 **范围** 等级锁

页级:引擎 BDB。
表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行
行级:引擎 INNODB ， 单独的一行记录加锁 （更详细的行锁、表锁，可以参考：http://www.cnblogs.com/charlesblc/p/5935326.html）

 

表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许
行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

上述三种锁的特性可大致归纳如下：
1） 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2） 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3） 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。



### 全局锁：

https://blog.csdn.net/qq_42322103/article/details/90480756

[全局锁能够对整个数据库实例加锁，使得整个库处于只读状态](https://blog.csdn.net/qq_42322103/article/details/90480756)，同时会阻塞DML和DDL语句以及更新类事务的提交语句。

flush tables with read lock;（简称FTWRL）命令可为数据库加全局锁
释放全局锁的语句也很简单：unlock tables;
此外，在客户端异常断开后，全局锁会自动释放。

全局锁非常典型使用场景是做全库逻辑备份。也就是把整库每个表都select出来存成文本。

通过FTWRL可以确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。

    如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
    如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

但是它的优势也很明显，能够解决因为数据更新问题导致的不一致性。
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756



 ## 表级锁

加表锁的方式：

```mysql
mysql> LOCK TABLES real_table WRITE, insert_table WRITE;
mysql> INSERT INTO real_table SELECT * FROM insert_table;
mysql> TRUNCATE TABLE insert_table;
mysql> UNLOCK TABLES;
```



 



MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。

### 表共享读锁（Table Read Lock）

### 表独占写锁（Table Write Lock）

当一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，此时MySQL将会如优先处理进程呢？通过研究表明，写进程将先获得锁（即使读请求先到锁等待队列）。但这也造成一个很大的缺陷，即大量的写操作会造成查询操作很难获得读锁，从而可能造成永远阻塞。其机制是通过控制一个系统变量（concurrent_insert）来改变，更详细的见原文。

 

MyISAM表的读和写是串行的，即在进行读操作时不能进行写操作，反之也是一样。但在一定条件下MyISAM表也支持查询和插入的操作的并发进行，其机制是通过控制一个系统变量（concurrent_insert）来进行的。（更详细的见原文）





MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁用于用于为单个表加锁，表锁的类型分为读锁和写锁。

加表锁的命令

lock tables tb_name(表名） read/write;

    1

释放锁的命令



    unlock tables;

当然也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程A中执行



    lock tables t1 read, t2 write

这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

有一种比较有名的表锁叫做意向锁 可以参考文章 详解 MySql InnoDB 中意向锁的作用

---

另一类表级的锁是MDL（metadata lock)。

### MDL（metadata lock)。

MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

于是在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

虽然MDL锁是系统默认会加的，但却是不能忽略的一个机制。
事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。
这就面临长事务的问题：事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。
但是数据量大了话，你kill掉这个长事务，可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756





## 事务 ACID属性

InnoDB锁与MyISAM锁的最大不同在于：一是支持事务（TRANCSACTION），二是采用了行级锁。我们知道事务是由一组SQL语句组成的逻辑处理单元，其有四个属性（简称ACID属性），分别为：

### 原子性（Atomicity）：

事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行；

### 一致性（Consistent）：

在事务开始和完成时，数据都必须保持一致状态；

### 隔离性（Isolation）：

数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行；

### 持久性（Durable）：

事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

##  行锁InnoDB

#####   **InnoDB有两种模式的行锁：**

### 共享锁【S锁】

1）共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
  ( Select * from table_name where ......lock in share mode)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

### 排他锁【X锁】

2）排他锁：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和 排他写锁。

(select * from table_name where.....for update)

又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。
注意这个时候,既不能加S锁也不能加X锁
————————————————





故名思议，行锁即对行数据行进行加锁，这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。。行锁在引擎层由n各个数据库引进行擎独自实现。因此，如MyISAM没有行锁，InnoDB则有行锁。

不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB拥有支持行锁的特性，这也是MyISAM被InnoDB替代的重要原因之一。

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

    两阶段锁协议指的是事务的执行分为两个阶段
    
        扩展阶段（此阶段只能创建锁而不能释放锁，即需要加锁的时候才加锁）
        收缩阶段(只能释放锁而不加锁）
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756





## 页锁

页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。
在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。
使用页级锁定的主要是BerkeleyDB存储引擎。
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756