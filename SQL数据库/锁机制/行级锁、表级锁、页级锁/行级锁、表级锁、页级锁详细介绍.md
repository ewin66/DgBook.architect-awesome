

# [【数据库】全局锁，表锁，行锁，页锁](https://blog.csdn.net/qq_42322103/article/details/90480756)



> ## [Mysql表锁、行锁、页锁](https://www.cnblogs.com/charlesblc/p/6288228.html)
>
> 参考 http://www.jb51.net/article/50047.htm 《MySQL行级锁、表级锁、页级锁详细介绍》
>
> 
>
> ##                  [MySQL中锁详解（行锁、表锁、页锁、悲观锁、乐观锁等）](https://www.cnblogs.com/jpfss/p/8890250.html)
>
> 原文地址：http://blog.csdn.net/mysteryhaohao/article/details/51669741
>
> 
>
> ## MySQL行级锁、表级锁、页级锁[详细介绍](https://www.jb51.net/article/50047.htm)
>
> https://www.jb51.net/article/50047.htm
>
>   更新时间：2014年05月13日 08:51:21

##  三种	 **范围** 等级锁

页级:引擎 BDB。
表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行
行级:引擎 INNODB ， 单独的一行记录加锁 （更详细的行锁、表锁，可以参考：http://www.cnblogs.com/charlesblc/p/5935326.html）

 

表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许
行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

上述三种锁的特性可大致归纳如下：
1） 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

>   比页级或表级锁定占用更多的内存。
> ·     当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。
> ·     如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。
> ·     用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。
>
> >  在以下情况下，表锁定优先于页级或行级锁定：
> > ·     表的大部分语句用于读取。
> > ·     对严格的关键字进行读取和更新，你可以更新或删除可以用单一的读取的关键字来提取的一行：
> > ·        UPDATE tbl_name SET column=value WHERE unique_key_col=key_value;
> > ·        DELETE FROM tbl_name WHERE unique_key_col=key_value;
> > ·     SELECT 结合并行的INSERT语句，并且只有很少的UPDATE或DELETE语句。
> > ·     在整个表上有许多扫描或GROUP BY操作，没有任何写操作。  

2） 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

>  行级锁定的优点：
> ·     当在许多线程中访问不同的行时只存在少量锁定冲突。
> ·     回滚时只有少量的更改。
> ·     可以长时间锁定单一的行。 

3） 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

## 事务 ACID属性

InnoDB锁与MyISAM锁的最大不同在于：一是支持事务（TRANCSACTION），二是采用了行级锁。我们知道事务是由一组SQL语句组成的逻辑处理单元，其有四个属性（简称ACID属性），分别为：

### 原子性（Atomicity）：

事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行；

### 一致性（Consistent）：

在事务开始和完成时，数据都必须保持一致状态；

### 隔离性（Isolation）：

数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行；

### 持久性（Durable）：

事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 全局锁

https://blog.csdn.net/qq_42322103/article/details/90480756

[全局锁能够对整个数据库实例加锁，使得整个库处于只读状态](https://blog.csdn.net/qq_42322103/article/details/90480756)，同时会阻塞DML和DDL语句以及更新类事务的提交语句。

flush tables with read lock;（简称FTWRL）命令可为数据库加全局锁
释放全局锁的语句也很简单：unlock tables;
此外，在客户端异常断开后，全局锁会自动释放。

全局锁非常典型使用场景是做全库逻辑备份。也就是把整库每个表都select出来存成文本。

通过FTWRL可以确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。

    如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
    如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

但是它的优势也很明显，能够解决因为数据更新问题导致的不一致性。
 

当然也可以通过事务来解决这一个问题，原理其实很简单，就是在可重复读隔离级别下开启一个事务。

官方自带的一个逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。这种方式也能解决我们的问题

### MVCC（多版本并发控制）

    MVCC（多版本并发控制）
    MVCC为数据库的并发性能提供了高效的解决方案。
    InnoDB的MVCC的实现方式为为每一个事务赋予一个自增且唯一的transaction ID。同时为涉及到事务增删改的数据行形成一个新版本，同时赋这个新版本一个row trx_id，row trx_id的值和对应事务的transaction ID值相同。
    在事务开始执行的时候，数据库会对整个库创建一个视图，对于在视图建时未提交的行数版本，该视图不可见。
    注意，对于已经创建但未提交的数据版本，视会通过row trx_id以及undo log回滚数据行之前已提交的版本。

但是存在即合理，一致性读是好，但前提是引擎要支持这个隔离级别。比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。

所以，single-transaction方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。

同样对于全库只读来说，也能通过set global readonly=true的方式来实现，readonly方式完全可以让全库进入只读状态，

但还是会建议使用FTWRL方式，主要有两个原因：

    在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，不建议使用。
    在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。
下面看看范围低一层的 表锁

版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756

---



 ## 表级锁

MySQL里面表级别的锁有两种：一种是**表锁**，一种是**元数据锁（meta data lock，MDL)**。

表锁

---

加表锁的方式：

```mysql
mysql> LOCK TABLES real_table WRITE, insert_table WRITE;
mysql> INSERT INTO real_table SELECT * FROM insert_table;
mysql> TRUNCATE TABLE insert_table;
mysql> UNLOCK TABLES;
```

MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。

### 表--共享读锁（Table Read Lock）

### 表--独占写锁（Table Write Lock）

当一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，此时MySQL将会如优先处理进程呢？通过研究表明，写进程将先获得锁（即使读请求先到锁等待队列）。但这也造成一个很大的缺陷，即大量的写操作会造成查询操作很难获得读锁，从而可能造成永远阻塞。其机制是通过控制一个系统变量（concurrent_insert）来改变，更详细的见原文。

 

MyISAM表的读和写是串行的，即在进行读操作时不能进行写操作，反之也是一样。但在一定条件下MyISAM表也支持查询和插入的操作的并发进行，其机制是通过控制一个系统变量（concurrent_insert）来进行的。（更详细的见原文）

----



表锁用于用于为单个表加锁，表锁的类型分为读锁和写锁。

加表锁的命令



    lock tables tb_name(表名） read/write;

释放锁的命令



    unlock tables;

当然也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程A中执行



    lock tables t1 read, t2 write

这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

有一种比较有名的表锁叫做意向锁 可以参考文章 详解 MySql InnoDB 中意向锁的作用

---

另一类表级的锁是MDL（metadata lock)。

### 元数据锁（meta data lock，MDL)。

MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

于是在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

虽然MDL锁是系统默认会加的，但却是不能忽略的一个机制。
事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。
这就面临长事务的问题：事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。
但是数据量大了话，你kill掉这个长事务，可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756







##  行锁InnoDB

#####   **InnoDB有两种模式的行锁：**

### 共享锁【S锁】

1）共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
  ( Select * from table_name where ......lock in share mode)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

### 排他锁【X锁】

2）排他锁：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和 排他写锁。

(select * from table_name where.....for update)

又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。
注意这个时候,既不能加S锁也不能加X锁
————————————————





故名思议，行锁即对行数据行进行加锁，这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。。行锁在引擎层由n各个数据库引进行擎独自实现。因此，如MyISAM没有行锁，InnoDB则有行锁。

不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB拥有支持行锁的特性，这也是MyISAM被InnoDB替代的重要原因之一。

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

    两阶段锁协议指的是事务的执行分为两个阶段
    
        扩展阶段（此阶段只能创建锁而不能释放锁，即需要加锁的时候才加锁）
        收缩阶段(只能释放锁而不加锁）
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756





## 页锁

页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。
在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。
使用页级锁定的主要是BerkeleyDB存储引擎。
————————————————
版权声明：本文为CSDN博主「沉晓」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42322103/article/details/90480756