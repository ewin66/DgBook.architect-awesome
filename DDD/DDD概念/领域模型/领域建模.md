领域建模，切记**不要以人为中心**，要区分什么是**系统的使用者**，什么是模型中**业务逻辑的参与者**



我所理解的就是这样**一个人与系统**，**系统与模型的交互**过程。





****



插一句 dudu 在闪存中说过的一段话：“领域驱动设计就是要以领域为中心，**围绕着领域转**，不然没必要叫领域“驱动”，最多只能叫“面向”领域。领域驱动出来的**产物**——代码，就是**领域模型**。”。

领域驱动设计使用自然语言（不懂技术的需求专家也可以看懂），去描述我们现实生活中的业务场景，设计的时候**忘掉数据库，忘掉表现层，忘掉应用层**，这样才会**设计出一个“纯净”的领域模型**，但是也要针对现实中的业务场景去设计和实现，要不然就会变成“面向对象设计”，只是一个“无所作为”的领域模型，并没有解决实际的业务需求。

**https://www.cnblogs.com/xishuai/p/domain_model_repository.html**



如果校验失败，直接抛异常不就好了

更新MessageState

最关键的一点：**我希望你能明确说出，消息发出去的标志是什么？**你这个方法里只是对给定的消息做了一些业务规则的验证；那为何不把这个领域服务取名为ValidateMessageService呢？**我之前那篇文章里和你谈到过，当你的方法里实际做的事情和你的方法的名称不一致时，说明你还没理解这个方法所代表的职责该谁执行，或者你还没理解这个职责的含义；**

说明你的业务场景中，怎么样才代表一个消息发送出去了

 我觉得像你这个场景，只要：
1.把消息new出来，构造函数中做必要的业务规则检查（包括发件人和收件人必须相同）；
2.继续做其他验证，比如发件人的消息不能超过100；（可以调用一个领域服务来验证，不通过直接抛异常即可）；
3.上述两步通过，则调用repository把消息持久化到db，就好了；

但这里	体现的**不是发消息**，而是**验证消息**，还不如用 **ValidateMessageService** 领域服务来的贴切，确实是这个道理

---



所以，怎么样才算消息发送了呢？难道不是把消息持久化起来就好了吗？然后我们其他可能专门有一个定时job定时从消息表获取未发送的消息；拿出来去发送，发送完成后再更新消息的状态是已发送；

当然，如果你不想定时，也可以把消息放到一个消息队列（这种方式就是我之前我贴的调用基础服务将消息发送到分布式消息队列的那句代码），然后由队列的监听放消费这个消息，拿到消息，去做真正的发送，发送成功后，修改消息的状态为已发送即可；  



---

CUR返回实体/集合

D返回Bool或ID

---





如果把组装的职责转移给其他对此感兴趣的对象，如应用中的客户对象，那就会使问题变得更加糟糕。客户知道需要让哪些领域对象来执行必须的计算，从而完成自己的工作。如果我们希望让客户程序来组装其所需的领域对象，那它就必须知道一些有关该对象内部结构的事情。为了保证领域对象中各个部分之间的关系满足所有不变量，客户程序又必须知道该对象上的某些规则。即使是调用构造函数也会使客户与它正在创建的具体类关联起来。对领域对象的实现所作的所有修改都需要客户做出相应修改，导致重构更加困难。

--









### 领域模型

领域模型表达的是我们**所关心的领域内的信息的结构**以及**各种业务规则的封装**；

领域模型是**业务的抽象描 述**，我只是描述我**可以发，**   

> can 可以能够  当满足条件时 判断再调用业务执行

**一个人与系统**，**系统与模型的交互**过程。



聚合根的最根本意义是**封装业务规则**

领域建模**只对我们所关心的信息和业务规则**进行建模，本身只定义了消息模型以及封装了一些**不变性规则**

不要把领域模型想的太强大了，认为要充血。最后，我在用Craig Larman提出的GRASP九大模式中的第一个模式，信息专家模式。希望对你有用：将**职责分配**给拥有**执行该职责所需信息的类**；

消息模型，并不只是包含消息本身，它是**整个消息业务场景的抽象**，并不只是表示一个已死的消息

> 建议你不要把这个**模型直接叫做Message**，因为这个名字大家就认为这是一个被发送的死的消息了。而不是你说的代表整个消息发送业务的模型了。是不是叫SendMessage**Service这个领域服务更好**呢？然后**领域服务有一个Send**方法。这个我是针对LZ38 楼的回复内容。



发送消息不是业务逻辑，而**是一个用例场景**！发送消息是一个复杂的过程，**领域能参与的只是这个过程中的一部分环节**。而你相当于是让领域完成整个发送消息的过程了。这就是我们本质的理解差别。

小蟋蟀：

是这样，如netfocus兄所说，这一块确实需要再考虑下，我曾经看到《领域驱动设计－软件核心复杂性应对之道》这本书中的货物运输系统的示例，其实作者在设计领域模型的时候，就类似netfoucs兄所说的**SendMessageService**，在这个领域模型中，Message只能算是一个消息领域模型的一个实体，就像是**Cargo**一样，**领域模型就像是一个具体业务场景内的聚合一样，包含实体也包含事件等**，这一方面内容需要更深入的理解一下，因为至少现在的消息领域模型只包含实体。
设计是我出现了问题，多谢netfocus兄不厌其烦的指点，真心感谢。



 

　　上面我和 netfocus 兄的讨论，主要包含两个内容：

- Message 对象可以发送自己（消息领域模型中的 Send 方法）？
- 发送消息的业务逻辑是赋值收件人（Send 方法中的代码）？

懂一点领域驱动设计思想的朋友都知道，**领域模型包含实体（Entity）、值对象（Value  Object）和领域服务（Domain  Service）**，这**三个模块组成一个整体，才能称为真正的领域模型**，那再看一下消息领域模型的代码，只不过打着领域模型的旗号，干着**伪领域模型的事，它最多充其量只是个实体**而已，事实上，它就**仅仅只是一个实体**，实体能发送实体自己？除非脑袋锈掉了，才会这样认为（不得不承认，我就是这样）。

**领域模型是业务逻辑的体现**，也就是说它是解决实际问题的，比如领域模型中的  Send  方法，在当时我硬说成是消息领域模型对发送消息的一种描述，把那个消息领域模型并不仅仅看作是一个对象，而是**一种对消息业务逻辑整体的一种描述**，其实这种观点是有有些正确点的，但是实际实现的时候却并没有**体现出这种思想**，体现出什么？Message  实体中放一个 Send 自己的方法，然后硬说成业务逻辑的抽象描述。

主要是 Message  这个伪领域模型设计的有问题，就比如命名，Message 对象中有个 Send  方法发送自己，听听感觉也不对。除了命名之外，就是对领域模型的理解偏差，**领域模型是实体、值对象和领域服务所组成的一个整体**，**体现**出来的就是**所具体的业务逻辑**，但是在之前的设计中却仅仅是一个实体，然后自己操作自己，其实说实话，有时候这样设计有点为了充血而充血，总想把领域模型设计的行为多些，让它看起来并不是那么贫血，其实这就有点设计过度了。



**只有外部可以更改自身的状态**，它不像别的实体，比如用户，可以更改自己的状态，也可以拥有自己的一些行为，也就是说把消息实体设计看起来贫血是正常的，因为这就是它的正常状态。



所谓**服务**，它**强调与其他对象的联系**。不像实体和值对象，服务完全是根据能够为客户做什么来定义的。服务往往**代表一种行为**，而**不是一个实体，是一个动词而不是一个名词**。服务**可以有一个抽象的、有意图的定义**，这与一个对象的定义有所不同。服务应该还有一个**定义好的职责**，它的职责和接口被定义为领域模型的一部分。**操作名应该来自通用语言**，如果通用语言中还没有这个操作名，则应该把它添加进去。调用的参数和返回的结果应该是领域对象。



### 领域服务



- **强调与其他对象的管理；**
- **代表一种行为，是动词而非名词；**
- **职责和定义是领域模型的一部分；**
- **操作名来来自通用语言（比如发消息，那就可以定义为 SendMessage，谁都可以看得懂）；**
- **调用的参数和返回结果应该是领域对象（比如实体）**



### **Repository（仓储）**

：协调领域和数据映射层，利用类似与集合的接口来访问领域对象。

　　这段定义可以说是相当的给力，主要包含两个重要信息点：

1. 协调领域
2. 访问领域对象



我再简单用发消息这个业务场景描述一下：

https://www.cnblogs.com/xishuai/p/domain_model_repository.html

1，用户发起发消息业务请求，界面调用应用层转账操作（传入参数为：标题，内容，发件人名称，收件人名称）
2，应用层首先创建一个发件人对象（通过仓储获得），然后再创建收件人对象和消息对象
3，发件人对象调用用户实体中的SendMessage操作（参数为收件人对象和消息对象）
4，在发件人对象中的SendMessage方法中，收件人对象调用用户实体中的ReceiveMessage操作（参数为发件人和消息对象）
5，在以上操作的完成后添加到事务操作（具体就是往消息仓储中添加消息领域对象）
6，应用层提交事务，向界面返回确认。
可以看到以上流程大致和转账操作是相似的，因为之前设计一直有个误区，就是把用户给忽略了，主要是围绕在消息设计，但是消息就像转账中的金钱一样，它只是一个信息的载体，能有什么作为呢？设计的误区啊。
后面 hailants 提出的消息系统无用户，也就是白板，我觉得如果是这种情况的话，就没必要使用领域驱动了，也正如你所说的，直接把消息贴在白板上就行了，没有任何的验证。
后面加入用户模块，那重点就是在用户的设计，这是用户的动作，在消息系统中，一个消息如果独立于用户是没有意义的，类似转账的creadit和debit，用户中的欣慰就是SendMessage和ReceviceMessage操作，最后你会发现，领域服务居然没了。



### 领域服务 ， 基础层 和应用层服务

领域驱动设计这本书中讲了一个转账事例，用来区分这三者之间的职责关系，如下：

　　**应用层－**资金转账应用服务

1. 读取输入(例如XML请求）
2. 发送消息给领域服务，要求处理
3. 监听确认消息
4. 决定用基础结构层的服务发送通告

　　**领域层**－资金转账领域服务

1. 必要的账户和分类账对象的相互作用，完成正确的提取和存入
2. 确认转账结果(转账是否被允许或拒绝等）

　　**基础结构层**－发送通告服务

1. 由应用选择通告方法，发送电子邮件、信件或者通过其他通信途径

　　通过这个事例，我们可以很清晰的分辨出这三个服务所对应的职责：

应用服务管流程；

领域服务管业务；

基础服务管后勤。

在这个转账事例中，我们在设计领域服务的时候就可以设计为：FundsTransferService，代表的是资金转账服务，转账就是一个**动词**。可以想一想，如果按照我们之前的那种设计思想，肯定会在资金实体中，定义一个转账方法，用来表示资金对象可以转自己？还真是蛮可笑的。在设计领域服务的时候可以这样考虑，**当一种业务逻辑，在实体中所不能表述的时候，或者表述的所不合理的时候，就要考虑一下领域服务设计的必要了**。

​		消息对象的发送状态不能由它自身确定，也就是说不能由它自己的某一个属性确定，它应该是一个动态的过程，也就是在验证发送业务规则成功后，retrun  之后的那个消息对象，表示这个消息对象的状态是已发送的，因为它是**符合发送消息业务规则并验证通过**，那它的状态就是已发送。



### **应用层代表什么，就是代表系统**

人使用系统，**系统提供外部功能**，系统**内部有领域模型**；

领域模型的意义，**领域模型是抽象的业务逻辑，它并不只是一些实体值，它描述的是一种业务的具体抽象**，就比如消息这个领 域模型，它**描述的是整个消息系统的所有抽象业务逻辑（比如发消息）**

一个动作，这个**动作由系统使用者（用户）产生**，

### Use	Case

既然设计了消息这个模型，就要充分考虑清楚这个**模型的业务规则是什么**；这个就是DDD一 直强调的聚合根要有true invariants【真正的不变量】，也就是把**真正的不变性封装到模型中**；

发送消息是一个**用例场景**，对应应用层的一个方法，就是你上面应用层的SendMessage方法。这个方法里的所有**实现就是在做消息发送， 而领域模型，即Message对象，只是承载了消息的信息而已**

Message对象的Send方法，只是在设置收件人 而已（所以按照方法里做的事情来定义方法名，那应该叫SetReceiveUser才对），~~我没办法认同设置收件人就是等于发送消息。~~消息对象的发送状态不能由它自身确定，也就是说不能由它自己的某一个属性确定，它应该是一个动态的过程，也就是在验证发送业务规则成功后，retrun  之后的那个消息对象，表示这个消息对象的状态是已发送的，因为它是**符合发送消息业务规则并验证通过**，那它的状态就是已发送。





并未把用户作为核心，用户只是一个参与者，或者称之为触发者，由他的参与会激发这个消息领域，然后完成消息领域中的核心业务－发消息，也就是像netfocus兄所说的**应用层相当于系统，人使用系统，系统提供外部功能，系统内部有领域模型**，换句话说就是**领域模型可以独立于用户存在**  【脱离人，无状态】





用户只是一个驱动者，和消息系统中一样，发消息这个业务也是对消息所造成的影响，那这个发这个动作谁来完成，或者Send这个业务逻辑的方法谁来定义？消息本身？还是应用层？还是用户？首先说下应用层，我觉得不可能，因为它是提供给**用户的调用者，协调者**，不可能会定于这些业务逻辑，这也**不在它的管辖范围之内**，

消息是一个载体， **只能别人来驱动发送**，也就是**应用层 的工作**

​	**领域模型抽象的描述业务，但并不是真实的业务场景**，



其实是和借书换书这个场景一样，**刷卡的身份验证是另外一个聚合或是领域**，当然也**可以进行重用**，只不过在借书换书这个场景之内，**加了**一些**属于这个场景的规则**（比如这个卡有没有开通借书功能等





### 有之以为利，无之以为用



“有”给人便利，**“无”发挥它的作用**。记得园中有位兄台的签名：只有**把自己置空，才能装更多的东西**。 其实就是这个道理，那老子的这个理论，如何和领域驱动设计联系起来呢？我当时是很不理解的，不知道我现在这样理解对不对？**“无”代表的是领域模型抽象的业务，只是描述业务逻辑**，你可以看不到，但它并不是不存在，就像是一个空杯子，虽然它是空的，但是它可以装一杯水，这就是它的价值，也就是“无”所代表的意义，我可以装一杯水**。“有”代表的是什么呢？就是具体的业务逻辑实现了，**也就是Send这个东西，用来和外部协调，就**不是具体的抽象了**，也就是说领域模型 它所描述的抽象业务逻辑具体化了，体现在应用层的SendMessage这个方法，在空杯子的体现就是这杯水装满了。

领域模型==业务单

领域模型	描述的是**抽象**  的**具体业务**，【所谓的“无”】是需求逻辑描述的可以容纳用户的业务需求

**不是具体的 某一次**业务

而 当**符合发送消息业务规则并验证通过**   填入好收件人 发件人 单据/消息内容 等信息 ，通过规则校验 以满足业务需求的

每张需要填写的表，定义出业务的规则，逻辑，流程，含义

-  填入信息	赋予抽象的领域模型具体的信息；也就是 在消息实体的**构造函数中去验证这些参数的规则**（比如参数不为空、字符串长度限制等等），如果验证成功则**创建对象成功**
- 此时，将构成**抽象**  的**具体业务** 

该业务中 	可达到待发送【**满足**可以发送的**条件**，但当前未必已发送的状态】

正如领域服务所定义的那样，**参数和返回值都是领域对象**，也就是**消息实体**，发送验证成功后进入持久化或者基础服务发送邮箱，整个发送消息的工作流程就是这样。



有之以为利，无之以为用。这个的意思就是只有空杯子才能装水。回到DDD，那就是用户的业务需求就是水，领域模型就是杯子，领域模型可以容纳用户的业务需求；

空杯子就是代表的“无”，所蕴含的意义就是可以装水，具体体现就是水杯的水装满了，也可能在这个装水之前我要对水进行验证，比如茶杯就不能装饮料，这就是空杯子所具有的规则。我是把空杯子看作是领域模型，它所描述的是**装水**这个“无”，也就是消息领域模型中的发送消息，并不是说它自己就驱动自己装水，而是说它描述这个东西，对消息领域模型而言，水杯水装满了的具体体现就是这条消息**已经赋予了收件人**，赋予了收件人的消息就相当于这个水杯的水满了， 才具有“有”的这个含义，这个业务操作才能具体的体现出来，至于基础层的发送消息或者是仓储的消息持久话，就相当于我在邮局写了这封信，把信息填写之后， 邮递员要让我填写收件人，写好之后，这封信就相对于我来说就已经发出了（也就是水杯的水装满了），那个邮递员邮递消息就像持久话一样，这就不是我所关心的问题了，因为水杯的水已经满了，至于你看不看得见是另一个问题。

message.send是有点误解，当一个消息具有发送的前提时（发件人，标题，内容），发送这个业务描述就是在这个消息上贴上收件人。理解这个可能有点问题，再回到空杯装水这个话题，装水这个定义就相当于消息领域中的send，指示我可以装水，水杯装水这个体现就是要有水，然后倒进水杯，对消息而言，这个水就是收件人。

你的邮件是如何发到目  标收件人那里的。你说真正发送你不关心，那谁去关心呢？如果是经典DDD，那就是由应用层去发送的，如果是domain event+event  sourcing，那可以实现为**通过响应事件**然后发送邮件；但这个事件也不是在设置收件人的时候产生的事件，而是在message被构造时，构造函数中所产生的事件。



在这个消息领域模型中只有发送这个业务逻辑，所以就会认为它怎么可能发送自己，在这个领域模型中围绕的是消息这个概念，也就包含发送消息，或者以后的处理消息，消息变更等等一些业务逻辑**，描述的是抽象  的具体业务，也就是我一直所说的“无”。**



理解上面的偏差，领域模型是业务的抽象描   述，我只是描述我可以发，message.send是有点误解，当一个消息具有发送的前提时（发件人，标题，内容），发送这个业务描述就是在这个消息上贴上收件人。理解这个可能有点问题，再回到空杯装水这个话题，**装水**这个定义就相当于**消息领域中的send**，指示我可以装水，水杯装水这个**体现就是要有水，然后倒进水杯，对消息而言，这个水就是收件人。**





### 两种逻辑



##### 1）业务逻辑；

##### **领域层**负责实现**业务逻辑**，

用户的业务需求是什么呢？1）用户关心什么，这个就是数据、信息；2）用户对这些数据有一定的业务规则定义在里面；这就是领域内的invariants，按照DDD的术语来说就是不变性，你可以理解为数据一致性；



领域模型自己无法驱动自己，领域模型就像杯子，它只能被别人使用；

所以对一个系统来说，那就是应用层使用领域模型	调用领域层实现需求；

##### 2）流程控制逻辑；

##### **应用层**负责实现**流程控制逻辑**；

用户的需求不是光靠领域层可以实现的， 用户的需求还包含了流程控制逻辑，以及一些非业务功能性需求，比如**事务强一致性，并发控制，发送消息，记录日志等**，这些东西**统一由应用层进行协调**。



对我们来说，就是**应用层创建“信”，然后把“信”交给基础服务**即可；基础服务通过消息管道，把信传出去，然后后面信怎么到收信人的收件箱里，那是另一个话题了；











## RESTful

REST	全称为“Representational State Transfer”，意为“**表现层状态转化**”。

> 在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。　　-Fielding



“Representational State Transfer”我们分解下：

- **Representational 表现层**：表现层表现什么，应该呈现资源（Resources），一个图片、一段文字、一个文件都成为资源，每个资源都用一个  URI（统一资源定位符）指向它，表现层就是调用 URI  把资源呈现出来，而且只是呈现，不做其他操作。举个例子：有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而  URI 应该只代表"资源"的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type  字段指定，这两个字段才是对"表现层"的描述。
- **State Transfer 状态转化**：访问一个网站，就表示客户端和服务器发生一次交互行为，在这个过程中，就不发生数据和状态的转化，上面说到 HTTP 协议具有无状态性，如果客户端操作服务器，必须要状态转化，这个体现在表现层上，所以叫“表现层状态转化”。

通过上面的理解，可以总结下什么是 RESTful 架构：

- 每一个 URI 代表一种资源。
- 客户端和服务器之间，传递这种资源的某种表现层。
- 客户端通过四个 HTTP 动词（PUT、GET、POST 和 DELETE），对服务器端资源进行操作，实现"表现层状态转化"。

------

上面 REST 和 RESTful 的概念，摘自很久之前的一篇博文：[初试ASP.NET Web API/MVC API（附Demo）](http://www.cnblogs.com/xishuai/p/3651370.html)，并做了部分修改。

我再来说一下自己现在的理解，首先，REST  是一种架构风格，而不是一种架构，一种架构风格可以用多种架构进行实现，一个架构中也可能包含多种架构风格，这两者的关系，你可以理解为抽象和实现的区别，另外，REST  严格来说，应该属于 Web 架构的一种架构风格，因为它离不开 HTTP 协议。

REST 架构风格的两个关键：

### 2.1 资源（Resources）

Web 资源的表述是 URI，一个规范的 URI 就是开放出来的一个资源，它是唯一并具有一定的规范，对资源的操作方式就是 HTTP 提供的方法（PUT、GET、POST 和 DELETE），资源的表现形式是多样的，比如：JSON、XML、YAML 等。

我们看一下常用的 URI：

- GET: cnblogs.com/getUser/1
- POST: cnblogs.com/createUser
- PUT: cnblogs.com/updateUser/1
- DELETE: cnblogs.com/deleteUser/1

很显然，这种 URI 不符合 REST 对资源的定义，我们尝试修改一下：

- GET: cnblogs.com/user/1
- POST: cnblogs.com/user
- PUT: cnblogs.com/user/1
- DELETE: cnblogs.com/user/1

`cnblogs.com/user/1`，这个 URI 一般表述的含义是：Id 为 1 的 User  资源，这个仅仅是表述，URI 并不包含对这个资源的任何操作，所以，像 getUser、createUser 这类操作就不合适，资源的操作是通过  HTTP 提供的方法，还有一点是，比如 POST 中的 `cnblogs.com/user` 和 `cnblogs.com/user/1` 有什么不同？第一种 POST，一般是创建一个新的 User 资源，创建完成后，一般会返回这样的一个 URI：`cnblogs.com/user/1`，第二种 POST，不是说创建一个 Id 为 1 的 User 资源，而是在 Id 为 1 的 User 资源下创建某种资源，你会发现，好的 URI 设计应该不包含动词。

### 2.2 状态（State）

首先，REST 是无状态的（Statelessness），我之前是一直不理解状态的含义，好像还把状态和资源格式（XML、JSON）混为一谈，现在想想确实太荒谬了，关于状态的几个要点：

- 状态分为：应用状态（**Application State**）和资源状态（**Resource State**）。
- **应用状态**：与某一特定**请求相关的状态信息**。
- **资源状态**：反映了某一存储在**服务器端资源在某一时刻的特定状态**。
- **客户端**负责维护应用状态，而**服务端**维护资源状态。
- 服务器端不保有任何与特定 HTTP 请求相关的资源。

> REST 中的无状态其实指的是应用状态，无状态的表现是**服务端不保存应用状态**，也就是客户端发起与请求相关的状态，应用状态是客户端在发起请求时提供的，那状态转化是什么意思？其实指的是服务端资源状态的转化，表现在客户端中，也就是上面所说的“表现状态转化”。

在 ASP.NET 应用程序中，我们都知道 Session  的概念，意为会话，也就是有关用户请求的会话，应该划分为应用状态，这个会话状态是保存在服务端的，从这一点上来说，这种设计就是 unRESTful  风格，REST  中的无状态，是客户端和服务端交互中所表达的一种概念，有时候，虽然应用状态可能不保存在服务端，但客户端发起的某些请求所表达的含义不恰当，也可以认为是不符合  RESTful 风格，比如客户端发起的请求中包含 Session ID，在服务端看来，客户端发起的这个请求，所表达的含义是要获取某个  Session，具体来说就是会话状态保存在服务端，这个虽然只是一个客户端请求的概念，但也可以认为这种设计是 unRESTful 风格。

总的来说，架构风格不是某一种具体架构，它是一种风格。

REST 参考资料：

- [REST](http://zh.wikipedia.org/wiki/REST)
- [深入浅出REST](http://www.infoq.com/cn/articles/rest-introduction)
- [理解RESTFul架构](http://mccxj.github.io/blog/20130530_introduce-to-rest.html)
- [无状态、REST、RESTful 和 Web Services](http://hiaero.net/rest-and-restful/)
- [对于REST中Statelessness的一点认识](http://www.cnblogs.com/Nyyrikki/archive/2009/06/16/1504191.html)

