



#                                              [ 分布式唯一ID生成方案](https://segmentfault.com/a/1190000015273990)                                         



- ​                                                         [                                                                                                                       分布式                                                         ](https://segmentfault.com/t/分布式/blogs)                                                     
- ​                                                         [                                                                                                                     ![img](assets/868271510-54cb382abb7a1_small.png)                                                                                                                       java                                                         ](https://segmentfault.com/t/java/blogs)                                                     

​                                                 1.7k 次阅读                                                  ·                                                  读完需要 3 分钟                                                                              

​                         

​                                                                                                                                                  

# 分布式ID的需求

在分布式系统中。ID有如下需求

1. 全局唯一性,不能出现重复的id号
2. 信息安全:防止恶意用户规矩id的规则来获取数据
3. 数据递增:保证我的下一ID一定大于上一个ID

# UUID

通用唯一识别码,16个字节128位的长数字 
组成部分:当前时间和时间序列+全局唯一性网卡地址 
优点:代码实现简单,不占用宽带,数据迁移不受影响 
缺点:无序,无法保证趋势递增,查询慢,不可读

# 雪花算法

国外的twitter分布式下ID生成算法 
1bit+41bit+10bit+10bit=62bit 
高位随机+毫秒数+机器码(数据中心+机器id)+10的流水号 
优点:代码实现简单,不占用宽带,数据迁移不受影响,低位趋势递增 
缺点:多台服务器时间一定要一样,无序无法保证趋势递增要求

# Mysql

优点:代码实现方便,性能不错,数字排序,可读性很强 
缺点:受限数据库,扩展麻烦,插入数据库才能拿到ID,单点故障问题 
主从同步的时候:电商下单–>支付 intsert master db select 数据 因为数据库同步延迟导致查不到这个数据,加cahe不是最好的解决方式,数据要求比较严谨的话查master主库.

# Redis

年份+当前这天属于这一年的第多少天+小时+redis自增 
2+3+2+5=12位 
数据多了可以设置一个失效时间重新生成, 
优点:不依赖数据,灵活方便,性能优于数据库,没有单故障,高可用 
缺点:需要占用网络资源,性能要比本地生成慢,需要增加插件