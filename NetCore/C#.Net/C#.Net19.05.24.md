##	.引用类型。值类型



### 堆和栈的区别

> 答:栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小.



### 类与结构的区别

> 　　1)、结构是值类型；
> 　　2)、结构不支持继承；
> 　　3)、结构不能定义默认的构造函数；
> 　　4)、结构不能定义析构函数；
> 　　5)、结构不能使用初始值设置域值 

### 深拷贝 浅拷贝



## OOP

###	继承性

> 继承的思想实现了 **属于（IS-A）** 关系。例如，哺乳动物 **属于（IS-A）** 动物，狗 **属于（IS-A）** 哺乳动物，因此狗 **属于（IS-A）** 动物

### 封装性

抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者*实现所需级别的抽象*。 
> C# 封装根据具体的需要，设置使用者的访问权限，并通过 **访问修饰符** 来实现。 
> https://www.runoob.com/csharp/csharp-encapsulation.html 
> 一个 **访问修饰符** 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示： 
>
> > - public：所有对象都可以访问；
> > - private：对象本身在对象内部可以访问；
> > - protected：只有该类对象及其子类对象可以访问
> > - internal：同一个程序集的对象可以访问；
> > - protected internal：访问限于当前程序集或派生自包含类的类型。
> >



### 多态性

> **多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。 
> 多态性可以是**静态**的或**动态**的。  
> https://www.runoob.com/csharp/csharp-polymorphism.html 
> 在**静态多态性**中，函数的响应是在编译时发生的。【函数重载，运算符重载】 
> 在**动态多态性**中，函数的响应是在运行时发生的。【**abstract** 抽象类	**virtual**虚方法】

### 	所有类的基类就是Object【System.Object】

> 支持 .[NET](https://www.baidu.com/s?wd=NET&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) Framework 类层次结构中的所有类，并为派生类提供低级别服务。这是 .NET Framework 中所有类的最终基类；它是类型层次结构的根。
>
> 如果说你的意思是所有类的最终基类，那么答案是Object，这个也决定了.[NET](https://www.baidu.com/s?wd=NET&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)平台的单根性质
>
> https://zhidao.baidu.com/question/579224748.html

### static静态成员

> 成员变量和成员函数前加static的作用？
>
> 答:它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作。

### 重载重写和覆盖

##### 重载（Overload）

是重新加载的意思，指的是同一个类中同名，但是参数列表不同的方法组（返回值不能区别函数是否重载），重载没有关键字。通俗点说重载是对内存中同一个类中的函数或方法进行重新加载的意思。

##### 重写（Override）

指子类修改父类中某个函数的函数体，需要重写的父类中的函数必须是由virtual、abstract 或override标注的，不能重写非虚方法或静态方法。
  Override是在继承的时候，如果你写的函数与要继承的函数函数特征（函数特征包括函数名，参数的类型和个数）相同，那么，加上这个关键字，在使用这个子类的这个函数的时候就看不见父类（或超类）的函数了，它被覆盖掉了。



##### 覆盖

   1、示意	覆盖指重新定义子类中与父类具有相同函数特征的的函数体。子类中有一函数和父类中函数的函数特征相同，但函数体不同，称为覆盖。这种覆盖又称为隐藏，是隐藏父类中相同的函数，并没有进行重写。

   2、发生条件	  在子类中写一个和基类一样名字(参数不同也算)的非虚函数,会让基类中的函数被隐藏,编译后会提示要求使用New关键字。

### using和new

> 在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？using 指令 和语句 new 创建实例 new 隐藏基类中方法。
>
> 答：using 引入名称空间或者使用非托管资源,new 新建实例或者隐藏父类方法.



### 虚函数vs抽像函数

答：虚函数：可由子类继承并重写的函数。抽像函数：规定其非虚子类必须实现的函数，必须被重写。



###   property 与 attribute

attribute:自定义属性的基类;

property :类中的属性







## 托管资源



> IDisposable接口的类，以下哪些项可以执行与释放或重置非托管资源相关的应用程序定义的任务？(多选) (   ABC     )
>
> A.Close			B.Dispose
>
> C.Finalize		D.using    





### GC是什么? 为什么要有GC?

> 答：GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理

垃圾回收（GC）功能，它替代了程序员 不过在C#中，不能直接实现Finalize方法，而是在析构函数中调用基类的Finalize()方法

## 线程安全

###  进程和线程的区别

线程和进程有区别

进程是系统进行资源分配和调度的单位；线程是CPU调度和分派的单位，一个进程可以有多个线程，这些线程共享这个进程的资源。

System.Threading.ThreaPool 类型封装了线程池的操作









## 泛型

OOP三大特性之一的继承，我们知道，C#语言中，object是所有类型的基类

> 1、object类型是一切类型的父类。
>
> 2、通过继承，子类拥有父类的一切属性和行为，任何父类出现的地方，都可以用子类来代替。
>
> 但是上面object类型的方法又会带来另外一个问题：装箱和拆箱，会损耗程序的性能。
>
> 微软在C#2.0的时候推出了泛型，可以很好的解决上面的问题。

###	作用：

为了促进代码的重用，尤其是算法的重用

###	优势：

（1）可重用性
（2）类型安全，在参数化的类中只有成员明确希望的数据类型才可以使用
（3）性能：避免了从Object的强制转换和值类型的装箱
（4）减小了内存消耗：避免装箱也就不在需要消耗堆上的内存。

>
> 执行时的行为：泛型也是对象，泛型类的“类型参数”变成了元数据；CLR会在需要的时候构造利用它们的类。
>
> 一个泛型类经过编译好之后和普通的类并没有什么区别。编译的结果只有元数据和CIL。基于值类型的泛型实例化：CLR会讲指定的类型参数放到CIL中合适的位置，从而创建一个具体化的泛型类型。所以CLR会为没个新的参数值创建具体的泛型类型
> 基于引用类型的实例化：CLR会创建一个具体化的泛型类型。以后，每次用一个引用类型参数来说实例化一个构造好的类型时，并在CIL中用Object引用替换类型参数，CLR都会重用以前生成好的泛型版本

**List<T>和T[]的区别是什么，平时你如何进行选择？**

> List<T>arrylist的泛型版本，大小是可变的，
>
> T[]继承自Array,大小是固定的。如果大小没有怎么变化，选择T[],一般情况下选择List<T>

### 拆箱装箱

从值类型接口转换到引用类型装箱。

从引用类型转换到值类型拆箱。

### 字典Dict和Hashtable

Dictionary<TKey, TValue>是做什么的？

.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？

> Dictionary是hashtable的泛型版本，用来存储键值对的.例如：sortlist，stack等

### 	泛型类型参数

> 在泛型类型或方法定义中，类型参数是在其实例化泛型类型的一个变量时，客户端指定的特定类型的占位符。  泛型类( `GenericList<T>`)无法按原样使用，因为它不是真正的类型；它更像是类型的蓝图。 若要使用 `GenericList<T>`，客户端代码必须通过指定尖括号内的类型参数来声明并实例化构造类型。 此特定类的类型参数可以是编译器可识别的任何类型。 可创建任意数量的构造类型实例，其中每个使用不同的类型参数。
>
> https://www.cnblogs.com/dotnet261010/p/9034594.html



###  ！！【泛型方法的性能最高，其次是普通方法，object方法的性能最低。】

### 	 注意：

1、泛型在声明的时候可以不指定具体的类型，但是在使用的时候必须指定具体类型

2、类实现泛型接口也是这种情况



###	泛型约束

怎么解决类型不安全的问题呢？那就是使用泛型约束。

所谓的泛型约束，实际上就是约束的类型T。使T必须遵循一定的规则。比如T必须继承自某个类，或者T必须实现某个接口等等。那么怎么给泛型指定约束？其实也很简单，只需要where关键字，加上约束的条件。

泛型约束总共有五种。

| 约束          | s说明                                                        |
| ------------- | ------------------------------------------------------------ |
| T：结构       | 类型参数必须是值类型                                         |
| T：类         | 类型参数必须是引用类型；这一点也适用于任何类、接口、委托或数组类型。 |
| T：new()      | 类型参数必须具有无参数的公共构造函数。 当与其他约束一起使用时，new() 约束必须最后指定。 |
| T：<基类名>   | 类型参数必须是指定的基类或派生自指定的基类。                 |
| T：<接口名称> | 类型参数必须是指定的接口或实现指定的接口。 可以指定多个接口约束。 约束接口也可以是泛型的。 |

1. 基类约束

   基类约束时，基类不能是密封类，即不能是sealed类。

   sealed类表示该类不能被继承，在这里用作约束就无任何意义，因为sealed类没有子类。

2. 接口约束

3. 引用类型约束 class

   引用类型约束保证T一定是引用类型的。

4. 值类型约束  struct

   值类型约束保证T一定是值类型的。

5. 无参数构造函数约束  new()

   泛型约束也可以同时约束多个

   

   

### 泛型的协变和逆变

> 协变和逆变是在.NET 4.0的时候出现的，只能放在接口或者委托的泛型参数前面， 
> out 协变covariant，用来修饰返回值； 
> in：逆变contravariant，用来修饰传入参数。
>
> https://www.cnblogs.com/dotnet261010/p/9034594.html



## 集合类型

### List, Set, Map是否继承自Collection接口?

> 答：List，Set是,Map不是

###  Set如何区分重复

Set元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?

> 答：Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。equals()和==方法决定引用值是否指向同一对像equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。

### HashMap和Hashtable的区别。

> 答：HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable.



###	常用集合

[C#中四种常用集合的运用(非常重要)](https://www.cnblogs.com/maj99/p/6322626.html)

**1.ArrayList**

**2.HashTable**

**3. 泛型集合: List<T>**

**4.泛型集合Dictionary<K,V>**

下面是各种常用的 **System.Collection** 命名空间的类。点击下面的链接查看细节。

| 类                                                           | 描述和用法                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [动态数组（ArrayList）](https://www.runoob.com/csharp/csharp-arraylist.html) | 它代表了可被单独**索引**的对象的有序集合。它基本上可以替代一个数组。但是，与数组不同的是，您可以使用**索引**在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。 |
| [哈希表（Hashtable）](https://www.runoob.com/csharp/csharp-hashtable.html) | 它使用**键**来访问集合中的元素。当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个**键/值**对。键用于访问集合中的项目。 |
| [排序列表（SortedList）](https://www.runoob.com/csharp/csharp-sortedlist.html) | 它可以使用**键**和**索引**来访问列表中的项。 排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。 |
| [堆栈（Stack）](https://www.runoob.com/csharp/csharp-stack.html) | 它代表了一个**后进先出**的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为**推入**元素，当您从列表中移除一项时，称为**弹出**元素。 |
| [队列（Queue）](https://www.runoob.com/csharp/csharp-queue.html) | 它代表了一个**先进先出**的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为**入队**，当您从列表中移除一项时，称为**出队**。 |
| [点阵列（BitArray）](https://www.runoob.com/csharp/csharp-bitarray.html) | 它代表了一个使用值 1 和 0 来表示的**二进制**数组。当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用**整型索引**从点阵列集合中访问各项，索引从零开始。 |



###	  [C#集合总结](https://www.cnblogs.com/yuyuefly/p/9685321.html)

> https://www.cnblogs.com/yuyuefly/p/9685321.html

## 递归	回调

### 	回调函数

> https://blog.csdn.net/sajiazaici/article/details/78702144





### 	递归函数

> https://www.cnblogs.com/ys9527/p/10114725.html

## 其他

### 在.Net中所有可序列化的类都被标记为[serializable]

### ### &和&&的区别。

答：&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）.

###  const与readonly的区别。

> 每一个class至多只可以定义一个static构造函数，并且不允许增加访问级别关键字，参数列必须为空。
>         为了不违背编码规则，通常把static数据成员声明为private，然后通过statci property提供读写访问。
>         const 关键字用于修改字段或局部变量的声明。它指定字段或局部变量的值不能被修改。常数声明引入给定类型的一个或多个常数。
>         const数据成员的声明式必须包含初值，且初值必须是一个常量表达式。因为它是在编译时就需要完全评估。
>         const成员可以使用另一个const成员来初始化，前提是两者之间没有循环依赖。
>         readonly在运行期评估赋值，使我们得以在确保“只读访问”的前提下，把object的初始化动作推迟到运行期进行。
>          readonly 关键字与 const 关键字不同：　const 字段只能在该字段的声明中初始化。readonly  字段可以在声明或构造函数中初始化。因此，根据所使用的构造函数，readonly 字段可能具有不同的值。另外，const 字段是编译时常数，而  readonly 字段可用于运行时常数。 
> 　　readonly 只能在声明时或者构造函数里面初始化，并且不能在 static 修饰的构造函数里面。

## 菜鸟教程

https://www.runoob.com/csharp/csharp-type-conversion.html

C# 教程	 	 	

 			C# 教程			

 			C# 简介			

 			C# 环境			

 			C# 程序结构			

 			C# 基本语法			

 			C# 数据类型			

 			C# 类型转换			

 			C# 变量			

 			C# 常量			

 			C# 运算符			

 			C# 判断			

 			C# 循环			

 			C# 封装			

 			C# 方法			

 			C# 可空类型			

 			C# 数组（Array）			

 			C# 字符串（String）			

 			C# 结构体（Struct）			

 			C# 枚举（Enum）			

 			C# 类（Class）			

 			C# 继承			

 			C# 多态性			

 			C# 运算符重载			

 			C# 接口（Interface）			

 			C# 命名空间（Namespace）			

 			C# 预处理器指令			

 			C# 正则表达式			

 			C# 异常处理			

 			C# 文件的输入与输出			

 C# 高级教程

 			C# 特性（Attribute）			

 			C# 反射（Reflection）			

 			C# 属性（Property）			

 			C# 索引器（Indexer）			

 			C# 委托（Delegate）			

 			C# 事件（Event）			

 			C# 集合（Collection）			

 			C# 泛型（Generic）			

 			C# 匿名方法			

 			C# 不安全代码			

 			C# 多线程			





