##	引用类型。值类型



### 堆和栈的区别

> 答:栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小.



### 类与结构的区别

> 　　1)、结构是值类型；
> 　　2)、结构不支持继承；
> 　　3)、结构不能定义默认的构造函数；
> 　　4)、结构不能定义析构函数；
> 　　5)、结构不能使用初始值设置域值 

### 深拷贝 浅拷贝



## OOP

继承性

封装性

多态性



### 	所有类的基类就是Object【System.Object】

> 支持 .[NET](https://www.baidu.com/s?wd=NET&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) Framework 类层次结构中的所有类，并为派生类提供低级别服务。这是 .NET Framework 中所有类的最终基类；它是类型层次结构的根。
>
> 如果说你的意思是所有类的最终基类，那么答案是Object，这个也决定了.[NET](https://www.baidu.com/s?wd=NET&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)平台的单根性质
>
> https://zhidao.baidu.com/question/579224748.html

### static静态成员

> 成员变量和成员函数前加static的作用？
>
> 答:它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作。

### 重载重写和覆盖

##### 重载（Overload）

是重新加载的意思，指的是同一个类中同名，但是参数列表不同的方法组（返回值不能区别函数是否重载），重载没有关键字。通俗点说重载是对内存中同一个类中的函数或方法进行重新加载的意思。

##### 重写（Override）

指子类修改父类中某个函数的函数体，需要重写的父类中的函数必须是由virtual、abstract 或override标注的，不能重写非虚方法或静态方法。
  Override是在继承的时候，如果你写的函数与要继承的函数函数特征（函数特征包括函数名，参数的类型和个数）相同，那么，加上这个关键字，在使用这个子类的这个函数的时候就看不见父类（或超类）的函数了，它被覆盖掉了。



##### 覆盖

   1、示意	覆盖指重新定义子类中与父类具有相同函数特征的的函数体。子类中有一函数和父类中函数的函数特征相同，但函数体不同，称为覆盖。这种覆盖又称为隐藏，是隐藏父类中相同的函数，并没有进行重写。

   2、发生条件	  在子类中写一个和基类一样名字(参数不同也算)的非虚函数,会让基类中的函数被隐藏,编译后会提示要求使用New关键字。

### using和new

> 在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？using 指令 和语句 new 创建实例 new 隐藏基类中方法。
>
> 答：using 引入名称空间或者使用非托管资源,new 新建实例或者隐藏父类方法.



### 虚函数vs抽像函数

答：虚函数：可由子类继承并重写的函数。抽像函数：规定其非虚子类必须实现的函数，必须被重写。



###   property 与 attribute

attribute:自定义属性的基类;

property :类中的属性



## 	拆箱装箱

从值类型接口转换到引用类型装箱。

从引用类型转换到值类型拆箱。





## 托管资源



> IDisposable接口的类，以下哪些项可以执行与释放或重置非托管资源相关的应用程序定义的任务？(多选) (   ABC     )
>
> A.Close			B.Dispose
>
> C.Finalize		D.using    





### GC是什么? 为什么要有GC?

> 答：GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理

垃圾回收（GC）功能，它替代了程序员 不过在C#中，不能直接实现Finalize方法，而是在析构函数中调用基类的Finalize()方法

## 线程安全

###  进程和线程的区别

线程和进程有区别

进程是系统进行资源分配和调度的单位；线程是CPU调度和分派的单位，一个进程可以有多个线程，这些线程共享这个进程的资源。

System.Threading.ThreaPool 类型封装了线程池的操作









## 泛型



## 集合类型

### List, Set, Map是否继承自Collection接口?

> 答：List，Set是,Map不是

###  Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?

> 答：Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。equals()和==方法决定引用值是否指向同一对像equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。

### HashMap和Hashtable的区别。

> 答：HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable.

## 递归	回调



## 其他

### 在.Net中所有可序列化的类都被标记为[serializable]

### ### &和&&的区别。

答：&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）.

###  const与readonly的区别。

> 每一个class至多只可以定义一个static构造函数，并且不允许增加访问级别关键字，参数列必须为空。
>         为了不违背编码规则，通常把static数据成员声明为private，然后通过statci property提供读写访问。
>         const 关键字用于修改字段或局部变量的声明。它指定字段或局部变量的值不能被修改。常数声明引入给定类型的一个或多个常数。
>         const数据成员的声明式必须包含初值，且初值必须是一个常量表达式。因为它是在编译时就需要完全评估。
>         const成员可以使用另一个const成员来初始化，前提是两者之间没有循环依赖。
>         readonly在运行期评估赋值，使我们得以在确保“只读访问”的前提下，把object的初始化动作推迟到运行期进行。
>          readonly 关键字与 const 关键字不同：　const 字段只能在该字段的声明中初始化。readonly  字段可以在声明或构造函数中初始化。因此，根据所使用的构造函数，readonly 字段可能具有不同的值。另外，const 字段是编译时常数，而  readonly 字段可用于运行时常数。 
> 　　readonly 只能在声明时或者构造函数里面初始化，并且不能在 static 修饰的构造函数里面。











