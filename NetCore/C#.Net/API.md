##  调用流程



## 接口整合

尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。

> ​	优化数据库查询语句。
> ​    优化数据库结构，多做索引，提高查询效率。
> ​    统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。
> ​    能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。
> ​    解决以上问题后，使用服务器集群来解决单台的瓶颈问题。

## EF

#####  贪婪加载：

**顾名思议就是把所有要加载的东西一 次性读取

```
1 using (var context = new MyDbContext()) 
2 { 
3     var orders = from o in context.Orders.Include("OrderDetails") select o;
4 }
```

当读取订单信息orders的时候，我们希望把订单的详细信息也读取出来，那么这里我们使用**Include**关键字将关联表也加载进 来。

> 1、减少数据访问的延迟，在一次数据库的访问中返回所有的数据。
> 2、一次性读取所有相关的数据，可能导致部分数据实际无需用到，从而导致读取数据的速度变慢，效率变低

#####  **延迟加载：**

即当我们需要用到的时候才进行加载（读取）

使用Lamabda表达式或者Linq 从 EF实体对象中查询数据时，EF并不是直接将数据查询出来，而是在用到具体数据的时候才会加载到内存。

当我们希望浏览某条订单信息的时候，才显示其对应的订单详细记录时，我们希望使用延迟加载来实现，这样不仅加快的了 读取的效率，同时也避免加载不需要的数据。延迟加载通常用于foreach循环读取数据时。

> 1、只在需要读取关联数据的时候才进行加载
> 2、可能因为数据访问的延迟而降低性能，因为循环中，每一条数据都会访问一次数据库，导致数据库的压力加大

### [EF延迟加载及原理深入解析](https://www.cnblogs.com/jasonwb/articles/3505130.html)

> https://www.cnblogs.com/jasonwb/articles/3505130.html

#### [EF延迟加载及原理深入解析](https://www.cnblogs.com/jasonwb/articles/3505130.html)

###	综上所述

，我们应该比较清楚时候应该使用哪种机制？我个人的建议是：

1、如果是在foreach循环中加载数据，那么使用延迟加载会比较好， 因为不需要一次性将所有数据读取出来，这样虽然有可能会造成n次数据库的查询，但 是基本上在可以接受的范围内。

2、如果在开发时就可以预见需要一次性加载所有的数据，包含关联表的所有数据， 那么使用使用贪婪加载是比较好的选择，但是此种方式会导致效率问题，特别是数据量大的情况下。

##### 	 延迟加载优点

延迟加载的优点是使用的时候才会去加载，特别是去查询导航属性的时候，这样EF只需要去查询使用的内容，避免了查询出多余的数据

##### 	延迟加载缺点

会查询多次SalesOrder表，增加数据库的压力，

##### 使用建议

只有在当前导航属性的内容每次都需要加载的时候就，采用Include("[导航属性]")来一次性加载过来，减少查询次数



## 版本号



## 落实过程中的问题

### UEider

### Execl





协作PMZ项目事务管理，协调工作



### 	简述ASP.NET WebApi相对于ASP.NET MVC的优点？

WebApi消息处理管道独立于ASP.NET平台，支持多种寄宿方式。



11、ORM中的延迟加载与直接加载有什么异同？

延迟加载（Lazy Loading）只在真正需要进行数据操作的时候再进行加载数据，可以减少不必要的开销。


12、简述Func<T>与Action<T>的区别？

Func<T>是有返回值的委托，Action<T>是没有返回值的委托。


13、开启一个异步线程的几种方式？多线程编程时的注意事项？

APM（Asynchrocous Programming  Model，比如：BeginXXX、IAsyncResult）、EAP（Event-Based Asynchronous  Pattern，比如：DownloadContentAsync）、TPL（Task Parallel  Library，比如：Task.Factory.StartNew）、async/await。

线程饿死、线程死锁、线程同步、线程安全。


14、简述Linq是什么，以及Linq的原理？并编写一个Linq to Object的示例代码

Linq（Language Integrated Query），其中Linq to Object是对Enumberable扩展方法的调用，在执行时会转化为Lambda然后执行。

## 高并发



可以控制连接池的连接数量条件好的话 可以用负载平衡



## 分布式

###	**事务补偿机制**	正逆操作对应

每一个业务服务或操作都有对应的可逆服务；可撤销可返回的才做一一对应

对于事务链上的任何一个服务正向和逆向操作均在事务管理和协同器上注册，由事务管理器接管所有的事务补偿和回滚操作。

### 	**事件源机制**	消费中间件消息

两个服务的真正解耦，关键就是异步消息和消息持久化机制

对于转账操作：

> 第一步调用本地的取款服务， 
> 第二步发送异地取款的异步消息到**消息中间件**。

如果第二步在本地，则保证事务的完整性基本无任何问题，即本身就是本地事务的管理机制。 
只要两个操作都成功即可以返回客户成功。如果服务调用失败则进行重试。 
中间过渡状态等待，在**约定的窗口期**内保证最终一致性。

> **事件源机制** 
> ​	https://mp.weixin.qq.com/s/w93v5q60bQ3vveF4XLslIQ?

事件源不仅解耦，也是微服务分布式查询的一个大前提，也就是是CQRS的大前提。



若采用事务补偿机制，基本可以是做到准实时的补偿，不会有太大的影响。必须要考虑客户需要的是否一定是最终一致性，**承受度**是如何的(忍受)。

而如果采用基于消息的最终一致性方式，则可能整个周期比较长，需要较长的时间才能给得到最终的一致性。

**隔离性** 要求下，考虑添加业务锁

**聚合内事务**

用代码弥补数据库的非事务性，分摊一部分处理分布式事务的麻烦

> 很多nosq数据库并不支持跨聚合事务，但在聚合内却能保证事务，所以在很多时候，我们可以把往常涉及到多个操作的组合合并到一个聚合内来操作，这样也算是一种分布式事务吧。虽然这些数据库并不支持跨聚合事务，但在一个聚合内却是支持事务的。









一个中型或大型公司往往由地理上分散的部门所组成，这些部门通常需要进行数据共享。针对这些共享数据，可以将其存储在某个站点上，需要的用户都从这个站点上存取。这种方案的优点是数据的一致性容易保证，但其缺点也是很突出的，那就是该站点的负载大、网络负载大，远程用户的数据响应迟缓。数据复制技术可以有效地解决这个问题，它通过将这些共享数据复制到位于不同地点的多个数据库中，从而实现数据的本地访问，减少了网络负荷，并提高了数据访问的性能，而且通过对数据库中的数据定期同步（通常是每天晚上），从而确保了所有的用户使用同样的、最新的数据。该技术适用于用户数量较大、地理分布较广、而且需要实时地访问相同数据的应用模式。

