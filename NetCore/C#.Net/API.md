##  调用流程





## 接口整合





## EF

#####  贪婪加载：

**顾名思议就是把所有要加载的东西一 次性读取

```
1 using (var context = new MyDbContext()) 
2 { 
3     var orders = from o in context.Orders.Include("OrderDetails") select o;
4 }
```

当读取订单信息orders的时候，我们希望把订单的详细信息也读取出来，那么这里我们使用**Include**关键字将关联表也加载进 来。

> 1、减少数据访问的延迟，在一次数据库的访问中返回所有的数据。
> 2、一次性读取所有相关的数据，可能导致部分数据实际无需用到，从而导致读取数据的速度变慢，效率变低

#####  **延迟加载：**

即当我们需要用到的时候才进行加载（读取）

使用Lamabda表达式或者Linq 从 EF实体对象中查询数据时，EF并不是直接将数据查询出来，而是在用到具体数据的时候才会加载到内存。

当我们希望浏览某条订单信息的时候，才显示其对应的订单详细记录时，我们希望使用延迟加载来实现，这样不仅加快的了 读取的效率，同时也避免加载不需要的数据。延迟加载通常用于foreach循环读取数据时。

> 1、只在需要读取关联数据的时候才进行加载
> 2、可能因为数据访问的延迟而降低性能，因为循环中，每一条数据都会访问一次数据库，导致数据库的压力加大

###	综上所述

，我们应该比较清楚时候应该使用哪种机制？我个人的建议是：

1、如果是在foreach循环中加载数据，那么使用延迟加载会比较好， 因为不需要一次性将所有数据读取出来，这样虽然有可能会造成n次数据库的查询，但 是基本上在可以接受的范围内。

2、如果在开发时就可以预见需要一次性加载所有的数据，包含关联表的所有数据， 那么使用使用贪婪加载是比较好的选择，但是此种方式会导致效率问题，特别是数据量大的情况下。

##### 	 延迟加载优点

延迟加载的优点是使用的时候才会去加载，特别是去查询导航属性的时候，这样EF只需要去查询使用的内容，避免了查询出多余的数据

##### 	延迟加载缺点

会查询多次SalesOrder表，增加数据库的压力，

##### 使用建议

只有在当前导航属性的内容每次都需要加载的时候就，采用Include("[导航属性]")来一次性加载过来，减少查询次数



## 版本号



## 落实过程中的问题

### UEider

### Execl





协作PMZ项目事务管理，协调工作



### 	简述ASP.NET WebApi相对于ASP.NET MVC的优点？

WebApi消息处理管道独立于ASP.NET平台，支持多种寄宿方式。



11、ORM中的延迟加载与直接加载有什么异同？

延迟加载（Lazy Loading）只在真正需要进行数据操作的时候再进行加载数据，可以减少不必要的开销。


12、简述Func<T>与Action<T>的区别？

Func<T>是有返回值的委托，Action<T>是没有返回值的委托。


13、开启一个异步线程的几种方式？多线程编程时的注意事项？

APM（Asynchrocous Programming  Model，比如：BeginXXX、IAsyncResult）、EAP（Event-Based Asynchronous  Pattern，比如：DownloadContentAsync）、TPL（Task Parallel  Library，比如：Task.Factory.StartNew）、async/await。

线程饿死、线程死锁、线程同步、线程安全。


14、简述Linq是什么，以及Linq的原理？并编写一个Linq to Object的示例代码

Linq（Language Integrated Query），其中Linq to Object是对Enumberable扩展方法的调用，在执行时会转化为Lambda然后执行。