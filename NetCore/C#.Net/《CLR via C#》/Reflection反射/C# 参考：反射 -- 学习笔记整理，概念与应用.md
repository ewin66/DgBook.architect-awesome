# [C# 参考：反射 -- 学习笔记整理，概念与应用](https://www.cnblogs.com/Dlonghow/archive/2008/07/14/1241484.html)



\1. **什么是反射**

 Reflection，中文翻译为 **反射**。
     
      这是.Net中获取 运行时类型信息 的方式，.Net的应用程序由几个部分：'程序集(Assembly)’、'模块(Module)’、'类型(class)’组成，而反射提供一种编程的方式，让程序员可以在程序运行期获得这几个组成部分的相关信息，例如：
      通常程序员面试题，有这样关于反射的解释：反射可以动态地创建类型的实例，还可以将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。 
      Assembly类可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并创建该类型的实例。
 Type类可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性等等，通过Type类可以得到这些要素的信息，并且调用之。
 MethodInfo包含方法的信息，通过这个类可以得到方法的名称、参数、返回值等，并且可以调用之。
     诸如此类，还有FieldInfo、PropertyInfo、ConstructorInfo、EventInfo等等，这些类都包含在System.Reflection命名空间。

 **2. 命名空间与装配件的关系** 
      很多人对这个概念可能还是很不清晰，对于合格的.Net程序员，有必要对这点进行澄清。
      命名空间类似与Java的包，但又不完全等同，因为Java的包必须按照目录结构来放置，命名空间则不需要。 

​     核心语：装配件是.Net应用程序执行的最小单位，编译出来的.dll、.exe都是装配件。

​      装配件和命名空间的关系不是一一对应，也不互相包含，一个装配件里面可以有多个命名空间，一个命名空间也可以在多个装配件中存在，这样说可能有点模糊，举个例子：
 装配件A：





 这两个装配件中都有N1和N2两个命名空间，而且各声明了两个类，这样是完全可以的，然后我们在一个应用程序中引用装配件A，那么在这个应用程序中，我们能看到N1下面的类为AC1和AC2，N2下面的类为AC3和AC4。
     接着我们去掉对A的引用，加上对B的引用，那么我们在这个应用程序下能看到的N1下面的类变成了BC1和BC2，N2下面也一样。
     如果我们同时引用这两个装配件，那么N1下面我们就能看到四个类：AC1、AC2、BC1和BC2。
     到这里，我们可以清楚一个概念了，命名空间只是说明一个类型是那个族的，比如有人是汉族、有人是回族；而装配件表明一个类型住在哪里，比如有人住在北京、有人住在上海；那么北京有汉族人，也有回族人，上海有汉族人，也有回族人，这是不矛盾的。
 
     上面我们说了，装配件是一个类型居住的地方，那么在一个程序中要使用一个类，就必须告诉编译器这个类住在哪儿，编译器才能找到它，也就是说必须引用该装配件。
     **问题出现了：**如果在编写程序的时候，也许不确定这个类在哪里，仅仅只是知道它的名称，就不能使用了吗？答案是可以，这就是**反射**了，就是在程序运行的时候提供该类型（class）的全地址，而去找到它。
 
 **3.运行期得到类型信息有什么用？** 
 有人也许疑问，既然在开发时就能够写好代码，干嘛还放到运行期去做，不光繁琐，而且效率也受影响。
 这就是个见仁见智的问题了，就跟早绑定和晚绑定一样，应用到不同的场合。有的人反对晚绑定，理由是损耗效率，但是很多人在享受虚函数带来的好处的时侯还没有意识到他已经用上了晚绑定。这个问题说开去，不是三言两语能讲清楚的，所以就点到为止了。
     我的看法是，晚绑定能够带来很多设计上的便利，合适的使用能够大大提高程序的复用性和灵活性，但是任何东西都有两面性，使用的时侯，需要再三衡量。 

接着说，运行期得到类型信息到底有什么用呢？
 还是举个例子来说明，很多软件开发者喜欢在自己的软件中留下一些接口，其他人可以编写一些插件（程序集（dll等））来扩充该软件的功能，比如我开发了一个销售图书的电子商务系统，其中的两个业务
     一是：新增加购买订单；
     二是，根据订单的唯一标识号获取某一订单信息。
 我希望以后可以很方便的扩展到多种数据库管理系统中（MS SQL SERVER, Oracle等）来完成相关业务，那么我需要声明一个接口：





 **5.动态创建对象实例的基础**
是实现抽象工厂的基础,也是实现抽象工厂的核心技术,通过它,可以动态创建一个你想要的对象.
如下面的例子是演示如何动态创建ChineseName或EnglishName的实例。
这个Demo和3中降到的Demo如出一辙，这个更简化些（用C#控制台应用程序 编写的），并提供完整的动态创建对象的代码，读者对照两者揣摩加联系。其实都很简单。